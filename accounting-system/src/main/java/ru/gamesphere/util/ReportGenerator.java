package ru.gamesphere.util;import org.jetbrains.annotations.NotNull;import org.jooq.*;import org.jooq.impl.DSL;import java.math.BigDecimal;import java.sql.*;import java.time.LocalDateTime;import static generated.Tables.*;import static org.jooq.impl.DSL.*;public class ReportGenerator {    private ReportGenerator() {    }    public static void getFirstTenOrganisationsByProductQuantity() {        try (Connection connection = ConnectionManager.open()) {            DSLContext context = DSL.using(connection, SQLDialect.POSTGRES);            Table<?> a = table(                    select(INVOICES.ORGANISATION_ID.as("org_id"), INVOICE_POSITIONS.QUANTITY.as("quantity"))                            .from(INVOICE_POSITIONS)                            .innerJoin(INVOICES)                            .on(INVOICE_POSITIONS.INVOICE_ID.eq(INVOICES.ID))            ).as("a");            Result<Record2<String, BigDecimal>> records = context.select(ORGANISATIONS.NAME.as("org_name"),                            sum(a.field(INVOICE_POSITIONS.QUANTITY)).as("quantity"))                    .from(a)                    .innerJoin(ORGANISATIONS).on(a.field("org_id", ORGANISATIONS.ID.getType()).eq(ORGANISATIONS.ID))                    .groupBy(field("org_name"))                    .orderBy(field("quantity").desc())                    .limit(10)                    .fetch();            records.forEach(record -> System.out.println(record.get("org_name") + " " + record.get("quantity")));        } catch (SQLException e) {            throw new RuntimeException(e);        }    }    public static void getOrganisationsByProductQuantity(int threshold) {        try (Connection connection = ConnectionManager.open()) {            DSLContext context = DSL.using(connection, SQLDialect.POSTGRES);            Table<?> a = table(                    select(INVOICES.ORGANISATION_ID.as("org_id"), INVOICE_POSITIONS.QUANTITY.as("quantity"))                            .from(INVOICE_POSITIONS)                            .innerJoin(INVOICES)                            .on(INVOICE_POSITIONS.INVOICE_ID.eq(INVOICES.ID))            ).as("a");            Result<Record2<String, BigDecimal>> records = context.select(ORGANISATIONS.NAME.as("org_name"),                            sum(a.field(INVOICE_POSITIONS.QUANTITY)).as("quantity"))                    .from(a)                    .innerJoin(ORGANISATIONS).on(a.field("org_id", ORGANISATIONS.ID.getType()).eq(ORGANISATIONS.ID))                    .groupBy(field("org_name"))                    .having(sum(a.field(INVOICE_POSITIONS.QUANTITY)).greaterThan(BigDecimal.valueOf(threshold)))                    .orderBy(field("quantity").desc())                    .fetch();            records.forEach(record -> System.out.println(record.get("org_name") + " " + record.get("quantity")));        } catch (SQLException e) {            throw new RuntimeException(e);        }    }    public static void getQuantityAndSumOfProductsByPeriodForEachDay(@NotNull Timestamp start, @NotNull Timestamp end) {        int totalSum = 0;        int totalQuantity = 0;        try (Connection connection = ConnectionManager.open()) {            DSLContext context = DSL.using(connection, SQLDialect.POSTGRES);            Table<?> a = table(                    select(PRODUCTS.NAME.as("name"),                            INVOICE_POSITIONS.PRICE.as("price"),                            INVOICE_POSITIONS.QUANTITY.as("quantity"),                            INVOICE_POSITIONS.INVOICE_ID.as("invoice_id"))                            .from(INVOICE_POSITIONS)                            .innerJoin(PRODUCTS).on(INVOICE_POSITIONS.PRODUCT_ID.eq(PRODUCTS.ID))            ).as("a");            Result<Record4<LocalDateTime, String, BigDecimal, BigDecimal>> records = context.select(INVOICES.DATE.as("date"),                            a.field("name", PRODUCTS.NAME.getType()).as("product_name"),                            sum(a.field("price", INVOICE_POSITIONS.PRICE.getType())).as("sum_price"),                            sum(a.field("quantity", INVOICE_POSITIONS.QUANTITY.getType())).as("sum_quantity"))                    .from(a)                    .innerJoin(INVOICES)                    .on(INVOICES.ID.eq(a.field("invoice_id", INVOICE_POSITIONS.INVOICE_ID.getType())))                    .where(field("date").between(start, end))                    .groupBy(INVOICES.DATE, field("name"))                    .orderBy(INVOICES.DATE)                    .fetch();            for (Record4<LocalDateTime, String, BigDecimal, BigDecimal> record : records) {                int currentSum = record.get("sum_price", INVOICE_POSITIONS.PRICE.getType());                int currentQuantity = record.get("sum_quantity", INVOICE_POSITIONS.QUANTITY.getType());                totalSum += currentSum;                totalQuantity += currentQuantity;                System.out.println(Timestamp.valueOf(record.get("date", INVOICES.DATE.getType())) + "\t"                        + record.get("product_name") + "\t"                        + currentSum + " "                        + currentQuantity);            }        } catch (SQLException e) {            throw new RuntimeException(e);        }        System.out.println("Total: " + totalSum + " " + totalQuantity);    }    public static void getAveragePriceByPeriod(@NotNull Timestamp start, @NotNull Timestamp end) {        try (Connection connection = ConnectionManager.open()) {            DSLContext context = DSL.using(connection, SQLDialect.POSTGRES);            Table<?> a = table(                    select(PRODUCTS.NAME.as("name"),                            INVOICE_POSITIONS.PRICE.as("price"),                            INVOICE_POSITIONS.INVOICE_ID.as("invoice_id"))                            .from(INVOICE_POSITIONS)                            .innerJoin(PRODUCTS).on(INVOICE_POSITIONS.PRODUCT_ID.eq(PRODUCTS.ID))            ).as("a");            Result<Record2<String, BigDecimal>> records = context.select(a.field("name", PRODUCTS.NAME.getType()).as("product_name"),                            avg(a.field("price", INVOICE_POSITIONS.PRICE.getType())).as("average_price"))                    .from(a)                    .innerJoin(INVOICES)                    .on(INVOICES.ID.eq(a.field("invoice_id", INVOICE_POSITIONS.INVOICE_ID.getType())))                    .where(field("date").between(start, end))                    .groupBy(a.field("name"))                    .orderBy(a.field("name"))                    .fetch();            records.forEach(record -> System.out.println(record.get("product_name") + "\t" + record.get("average_price", Integer.class)));        } catch (SQLException e) {            throw new RuntimeException(e);        }    }    public static void getCompanyProductListByPeriod(@NotNull Timestamp start, @NotNull Timestamp end) {        try (Connection connection = ConnectionManager.open()) {            DSLContext context = DSL.using(connection, SQLDialect.POSTGRES);            Table<?> a = table(                    select(INVOICES.ID.as("id"),                            INVOICES.ORGANISATION_ID)                            .from(INVOICES)                            .where(field("date").between(start, end))            ).as("a");            Table<?> b = table(                    select(ORGANISATIONS.NAME.as("org_name"),                            a.field("id", INVOICES.ID.getType()).as("invoice_id"))                            .from(a)                            .rightJoin(ORGANISATIONS)                            .on(a.field("organisation_id", INVOICES.ORGANISATION_ID.getType()).eq(ORGANISATIONS.ID))            ).as("b");            Result<Record2<String, String>> records = context.select(b.field("org_name", ORGANISATIONS.NAME.getType()),                            PRODUCTS.NAME.as("product_name"))                    .from(b)                    .leftJoin(INVOICE_POSITIONS)                    .on(b.field("invoice_id", INVOICES.ID.getType()).eq(INVOICE_POSITIONS.INVOICE_ID))                    .leftJoin(PRODUCTS)                    .on(INVOICE_POSITIONS.PRODUCT_ID.eq(PRODUCTS.ID))                    .groupBy(b.field("org_name", ORGANISATIONS.NAME.getType()), field("product_name"))                    .orderBy(b.field("org_name", ORGANISATIONS.NAME.getType()))                    .fetch();            for (Record2<String, String> record : records) {                String productName = record.get("product_name") == null ? "" : record.get("product_name", String.class);                System.out.println(record.get("org_name") + "\t"                        + productName);            }        } catch (SQLException e) {            throw new RuntimeException(e);        }    }}